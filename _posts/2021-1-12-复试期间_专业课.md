---
published: true
title: 复试期间有关Java的准备
category: Java
tags: 
  - 基础语法知识
layout: post


---

#20200302
4：迭代：重复执行某一过程/程序/代码段，直到满足一定的条件

#20200303
5：TCP协议：SMTP TELNET HTTP FTP
	UDP协议：DNS TFTP RIP DHCP BOOTP IGMP
	常见端口对应服务：
	21/20：ftp
	22：ssh
	23：telnet
	25：smtp
	53：dns
	67/68：bootp
	69：tftp
	79：finger
	80：http
	99：Metagram Relay（亚对策延时）/不常见

#20200305
6：动态规划
	①由当前current“阶段”的结果可以推出下一个阶段的结果--->简单递推问题 
	②已经保证当前阶段是最优结果，只要保证下一个阶段也是最优结果，就可以得到最优结果--->贪心问题
	③必须知道之前所有阶段的情况，并组合，才能得到最优结果--->搜索问题
	④乍一看需要知道之前所有阶段的情况(和组合)，但实际只要知道上一阶段的某种或某些状态，就可以把问题转换为递推或者递归问题，进而求出结果--->动态规划问题
	三要素：
	重叠子问题，最优子结构，状态转移方程
	
#20200306
7：docker常用参数
	-i:交互式操作
	-t:终端
	-d:后台运行
	运行容器：docker run -it --name ID image_name /bin/bash   (根据情况是否加 -d 后台运行)
	进入容器：docker exec -it id /bin/bash
	容器的导入导出：export import
	导入导出镜像： save load
	
	
#20200309
8：Scanner类
	hasnext  hasnextline
	
9：字符串转化为数字的两种方式
	1）：通过Integer.valueof()
	2）：通过先转化为字符数组，然后转化为数字

10：8种基本数据类型
byte short int long float double char boolean 

11：长度的方法
	数组：length
	字符串：length()
	集合：size()

#20200307
1：模糊查询： select 字段 from 表 where 某字段 like 条件；
	条件一般有以下四种：
	%   ：可表示多个字符 %DATA，DATA%，%DATA%三种形式
	_   : 表示任意单一字符 同%有三种形式
	 [] :  
	 [^]:
	 可代替like的关键字：（where后边使用）
	 instr： instr(row_name,msg)>0
	 locate：locate(msg,row_name)>0
	 position：position(msg in row_name) find_in_set:适合列属性有分隔符的形式，比如”1,2,3“查2，但若有name=“蔡添”，
	 find_in_set（“添”，name）是查不到的。					
	 一般来说，findinset就比like更精确，find_in_set函数比like查到的记录要小
note：
	使用_或者%开头（比如%添）进行模糊查询，索引会失效

2：mysql引擎:
	1）MYISAM:
	特点：
		不支持事务，也不支持外键，对事务完整性没有要求，访问速度快
	适用情况：
		以insert、select为主的应用
	2）InnoDB：
	特点：
		提供事务安全（提交，回滚，崩溃恢复能力），写的效率相对差一点相比myisam，且占用更多的磁盘空间来保存数据和索引。
		支持自动增长列，支持外键约束
	3）memory
	特点：
		使用内存中的数据来创建表。数据存放在内存中，默认使用HASH索引，一旦服务关闭，表中数据就会丢失。
	优点：
		检索效率高，不支持like等模糊查询
	适用情况：
		内容变化不频繁的表，或者统计操作的中间表
	4）MERGE
	特点：
		一组myisam表的组合，这些表结构必须完全相同
		本身没有数据，对merge类型表的curd其实都是对内部myisam表进行的


递归和迭代的区别：
	递归：程序调用自身（大化小，和分治的思想类似）
		可读性好，代码精简；但浪费空间，递归层数太多容易造成堆栈溢出
	迭代：利用变量的原值推出新值
		运行效率好一点，但代码不如递归精简

进程间通信：
	1：管道 pipe fork
	2：共享内存
	3：信号量
	4: 消息队列
进程产生死锁：
	原因：
		1：竞争资源
		2：进程推进顺序不适
	必要条件：
		1：互斥条件
		2：不剥夺条件
		3：请求和保持条件
		4：循环等待条件
	避免方法：
		1：线程按照一定顺序加锁
		2：线程尝试获取锁的时候加上一定的时限，超过时限则放弃请求，自动释放占有的锁
		3：死锁检测（释放所有锁回退，等待一定随机时间后尝试）
		
SpringMVC工作流程：
	1：Spring MVC请所有的请求都提交给DispatcherServlet
	2：DispatcherServlet查询一个或多个HandlerMapping,找到处理请求的Controller
	3：DispatcherServlet请请求提交到目标Controller
	4：Controller进行业务逻辑处理后，会返回一个ModelAndView
	5: 找到ModelAndView对象指定的视图对象
	6: 视图对象负责渲染返回给客户端

SQL:
	ROUND(column_name,decimals)  四舍五入
	ROUND(要舍入的字段,返回的小数位数)
	比如 select id，ROUND(Grade,0) as RESULTABLE from Score;
数据库四范式：
	第一范式：每个属性为不可分的原子（基本所有的都符合）
	第二范式：非主属性完全依赖于候选键
		（比如表候选键为学号+课程号，单学号可以推出姓名，就可以在拆分出来一个）
	第三范式：消除非主属性对候选键的传递依赖
		比如 学号-》系主任，学号-》系名-》系主任就需要拆分为学号-》系名，系名-》系主任
	BCNF范式：消除每一属性d对候选键的传递依赖
？	第四范式：消除非平凡且非FD的多值依赖(MVD)

？Java：
		拷贝：
	
JVM：（默认B单位，也可为KB,MB）
	Xms：程序启动时占用内存大小	（初始堆大小）
	Xmx：程序运行时最大占用内存大小 （最大堆大小）
	Xss：每个线程的堆栈大小
	Xmn：年轻代大小（堆大小=年轻代+年老代+持久代）
	
	getMethods()：获取本类以及父类/父接口所有的公共方法
	getDeclaredMethods()：获取本类所有方法，包括私有
	
常见网络错误码：
200：正常
3XX：重定向状态码（主要是网页位置发生变化）
400：服务器不理解请求的语法
401：请求身份验证
403：服务器拒绝请求
404：服务器上没有对应的文件网页
406：不接受
407：需要代理授权
408：请求超时
410：请求的资源已经永久删除
500：服务器遇到错误
503：服务不可用

红黑树特点：
每个节点非红必黑
根节点比黑
每个红节点其子节点必黑
从任意节点到每个叶子节点其路径相同数目的黑节点


spring用到的代理模式:
beanFactory:简单工厂模式 以及单例模式（BeanFactory作为全局访问点）
AOP的处理中:适配器模式（使得由于接口不兼容的类能一起工作）
Wrapper，Decorator：包装器模式，动态地给一个对象添加一些额外地职责
aop中地JdkDynamicAopProxy和Cglib2AopProxy：代理模式
ApplicationListener：观察者模式：一个对象改变，所有依赖于它的对象都动态改变
实例化对象时：策略模式
jdbcTemplate：模板方法模式

Java的四种引用：
强引用：A a =new A（）；无论如何也不会被回收
软引用：新建对象但堆内存不足时可能被回收
弱引用：每一次gc都会回收
虚引用：跟对象回收没有关系，和引用队列配合使用

GC：
场所:主要是在堆，其次在方法区
堆：新生代，老生代，永久代（方法区）
回收条件：
	1：该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例；
	2：加载该类的ClassLoader已经被回收；
	3：无法在任何地方通过反射访问该类的方法

Java对象生命周期：创建，应用，不可见（比如if，while内部定义的变量，程序本身不再持有该对象的任何强引用），不可达（对象不被任何强引用持有），收集，终结，重新分配


黑盒测试：功能测试 等价类划分 边界值分析 因果图（针对测试用例的输入）  场景法（基于流程图的方式） 
白盒测试：静态：代码检查，静态结构分许  动态：单元测试，同行校审

死锁必要条件：
互斥条件
环路等待
不剥夺条件
请求与保持